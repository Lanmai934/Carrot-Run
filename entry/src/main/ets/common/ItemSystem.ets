// é“å…·ç³»ç»Ÿ - ç®¡ç†æ¸¸æˆä¸­çš„å„ç§é“å…·
import { Vector2 } from './PhysicsEngine'
import { GameConfig } from './GameConfig'

// é“å…·ç±»å‹æšä¸¾
export enum ItemType {
  COIN = 'coin',
  SPEED_BOOST = 'speed_boost',
  SHIELD = 'shield',
  MAGNET = 'magnet',
  JUMP_BOOST = 'jump_boost',
  DOUBLE_SCORE = 'double_score',
  INVINCIBLE = 'invincible',
  SLOW_TIME = 'slow_time'
}

// é“å…·æ•ˆæœç±»å‹
export enum EffectType {
  INSTANT = 'instant',      // ç¬æ—¶æ•ˆæœ
  DURATION = 'duration',    // æŒç»­æ•ˆæœ
  PASSIVE = 'passive'       // è¢«åŠ¨æ•ˆæœ
}

// é“å…·æ•ˆæœæ¥å£
export interface ItemEffect {
  type: EffectType
  duration?: number         // æŒç»­æ—¶é—´ï¼ˆæ¯«ç§’ï¼‰
  value: number            // æ•ˆæœå€¼
  stackable: boolean       // æ˜¯å¦å¯å åŠ 
}

// é“å…·é…ç½®æ¥å£
export interface ItemConfig {
  type: ItemType
  name: string
  description: string
  icon: string
  rarity: 'common' | 'rare' | 'epic' | 'legendary'
  effect: ItemEffect
  spawnWeight: number      // ç”Ÿæˆæƒé‡
  price?: number          // å•†åº—ä»·æ ¼
}

// é“å…·å®ä¾‹ç±»
export class Item {
  public position: Vector2
  public size: Vector2
  public type: ItemType
  public config: ItemConfig
  public collected: boolean = false
  public animationTime: number = 0
  public glowIntensity: number = 0

  constructor(x: number, y: number, type: ItemType) {
    this.position = new Vector2(x, y)
    this.size = new Vector2(30, 30)
    this.type = type
    this.config = ItemManager.getItemConfig(type)
  }

  update(deltaTime: number): void {
    if (this.collected) return

    // æ›´æ–°åŠ¨ç”»
    this.animationTime += deltaTime
    
    // æµ®åŠ¨åŠ¨ç”»
    const floatOffset = Math.sin(this.animationTime * 0.003) * 5
    this.position.y += floatOffset * deltaTime * 0.001
    
    // å‘å…‰æ•ˆæœ
    this.glowIntensity = (Math.sin(this.animationTime * 0.005) + 1) * 0.5
  }

  render(context: CanvasRenderingContext2D): void {
    if (this.collected) return

    context.save()
    
    // ç»˜åˆ¶å‘å…‰æ•ˆæœ
    if (this.config.rarity !== 'common') {
      const glowRadius = 20 + this.glowIntensity * 10
      const gradient = context.createRadialGradient(
        this.position.x + this.size.x / 2, this.position.y + this.size.y / 2, 0,
        this.position.x + this.size.x / 2, this.position.y + this.size.y / 2, glowRadius
      )
      
      const glowColor = this.getRarityColor()
      gradient.addColorStop(0, `${glowColor}80`)
      gradient.addColorStop(1, `${glowColor}00`)
      
      context.fillStyle = gradient
      context.fillRect(
        this.position.x - glowRadius / 2,
        this.position.y - glowRadius / 2,
        this.size.x + glowRadius,
        this.size.y + glowRadius
      )
    }
    
    // ç»˜åˆ¶é“å…·å›¾æ ‡
    this.renderIcon(context)
    
    context.restore()
  }

  private renderIcon(context: CanvasRenderingContext2D): void {
    const centerX = this.position.x + this.size.x / 2
    const centerY = this.position.y + this.size.y / 2
    const radius = this.size.x / 2

    context.fillStyle = this.getItemColor()
    context.beginPath()
    context.arc(centerX, centerY, radius, 0, Math.PI * 2)
    context.fill()

    // ç»˜åˆ¶é“å…·ç¬¦å·
    context.fillStyle = 'white'
    context.font = '16px Arial'
    context.textAlign = 'center'
    context.textBaseline = 'middle'
    context.fillText(this.getItemSymbol(), centerX, centerY)
  }

  private getItemColor(): string {
    switch (this.type) {
      case ItemType.COIN: return '#FFD700'
      case ItemType.SPEED_BOOST: return '#FF4500'
      case ItemType.SHIELD: return '#4169E1'
      case ItemType.MAGNET: return '#DC143C'
      case ItemType.JUMP_BOOST: return '#32CD32'
      case ItemType.DOUBLE_SCORE: return '#9932CC'
      case ItemType.INVINCIBLE: return '#FFD700'
      case ItemType.SLOW_TIME: return '#00CED1'
      default: return '#808080'
    }
  }

  private getItemSymbol(): string {
    switch (this.type) {
      case ItemType.COIN: return 'Â¥'
      case ItemType.SPEED_BOOST: return 'âš¡'
      case ItemType.SHIELD: return 'ğŸ›¡'
      case ItemType.MAGNET: return 'ğŸ§²'
      case ItemType.JUMP_BOOST: return 'â†‘'
      case ItemType.DOUBLE_SCORE: return 'Ã—2'
      case ItemType.INVINCIBLE: return 'â˜…'
      case ItemType.SLOW_TIME: return 'â°'
      default: return '?'
    }
  }

  private getRarityColor(): string {
    switch (this.config.rarity) {
      case 'common': return '#FFFFFF'
      case 'rare': return '#00FF00'
      case 'epic': return '#9932CC'
      case 'legendary': return '#FFD700'
      default: return '#FFFFFF'
    }
  }

  collect(): ItemEffect {
    this.collected = true
    return this.config.effect
  }

  getValue(): number {
    return this.config.effect.value
  }
}

// é“å…·ç®¡ç†å™¨
export class ItemManager {
  private static itemConfigs: Map<ItemType, ItemConfig> = new Map()
  private static initialized: boolean = false

  static initialize(): void {
    if (this.initialized) return

    // åˆå§‹åŒ–é“å…·é…ç½®
    this.itemConfigs.set(ItemType.COIN, {
      type: ItemType.COIN,
      name: 'é‡‘å¸',
      description: 'æ”¶é›†é‡‘å¸æ¥è´­ä¹°æ–°è§’è‰²å’Œé“å…·',
      icon: 'Â¥',
      rarity: 'common',
      effect: {
        type: EffectType.INSTANT,
        value: 10,
        stackable: true
      },
      spawnWeight: 50
    })

    this.itemConfigs.set(ItemType.SPEED_BOOST, {
      type: ItemType.SPEED_BOOST,
      name: 'åŠ é€Ÿé“å…·',
      description: 'çŸ­æ—¶é—´å†…å¤§å¹…æå‡ç§»åŠ¨é€Ÿåº¦',
      icon: 'âš¡',
      rarity: 'rare',
      effect: {
        type: EffectType.DURATION,
        duration: 5000,
        value: 1.5,
        stackable: false
      },
      spawnWeight: 15,
      price: 50
    })

    this.itemConfigs.set(ItemType.SHIELD, {
      type: ItemType.SHIELD,
      name: 'ä¿æŠ¤ç›¾',
      description: 'æŠµå¾¡ä¸€æ¬¡éšœç¢ç‰©æ’å‡»',
      icon: 'ğŸ›¡',
      rarity: 'rare',
      effect: {
        type: EffectType.DURATION,
        duration: 10000,
        value: 1,
        stackable: false
      },
      spawnWeight: 12,
      price: 75
    })

    this.itemConfigs.set(ItemType.MAGNET, {
      type: ItemType.MAGNET,
      name: 'å¸é“çŸ³',
      description: 'è‡ªåŠ¨æ”¶é›†å‘¨å›´çš„é‡‘å¸',
      icon: 'ğŸ§²',
      rarity: 'epic',
      effect: {
        type: EffectType.DURATION,
        duration: 8000,
        value: 100, // å¸å¼•èŒƒå›´
        stackable: false
      },
      spawnWeight: 8,
      price: 100
    })

    this.itemConfigs.set(ItemType.JUMP_BOOST, {
      type: ItemType.JUMP_BOOST,
      name: 'è·³è·ƒå¢å¼º',
      description: 'å¢åŠ è·³è·ƒé«˜åº¦å’Œè·ç¦»',
      icon: 'â†‘',
      rarity: 'rare',
      effect: {
        type: EffectType.DURATION,
        duration: 6000,
        value: 1.3,
        stackable: false
      },
      spawnWeight: 10,
      price: 60
    })

    this.itemConfigs.set(ItemType.DOUBLE_SCORE, {
      type: ItemType.DOUBLE_SCORE,
      name: 'åŒå€ç§¯åˆ†',
      description: 'çŸ­æ—¶é—´å†…è·å¾—åŒå€ç§¯åˆ†',
      icon: 'Ã—2',
      rarity: 'epic',
      effect: {
        type: EffectType.DURATION,
        duration: 10000,
        value: 2,
        stackable: false
      },
      spawnWeight: 6,
      price: 120
    })

    this.itemConfigs.set(ItemType.INVINCIBLE, {
      type: ItemType.INVINCIBLE,
      name: 'æ— æ•ŒçŠ¶æ€',
      description: 'çŸ­æ—¶é—´å†…å…ç–«æ‰€æœ‰ä¼¤å®³',
      icon: 'â˜…',
      rarity: 'legendary',
      effect: {
        type: EffectType.DURATION,
        duration: 5000,
        value: 1,
        stackable: false
      },
      spawnWeight: 3,
      price: 200
    })

    this.itemConfigs.set(ItemType.SLOW_TIME, {
      type: ItemType.SLOW_TIME,
      name: 'æ—¶é—´å‡ç¼“',
      description: 'å‡ç¼“æ¸¸æˆæ—¶é—´ï¼Œæ›´å®¹æ˜“èº²é¿éšœç¢',
      icon: 'â°',
      rarity: 'legendary',
      effect: {
        type: EffectType.DURATION,
        duration: 4000,
        value: 0.5, // æ—¶é—´å€ç‡
        stackable: false
      },
      spawnWeight: 2,
      price: 250
    })

    this.initialized = true
  }

  static getItemConfig(type: ItemType): ItemConfig {
    const config = this.itemConfigs.get(type)
    if (!config) {
      throw new Error(`æœªæ‰¾åˆ°é“å…·é…ç½®: ${type}`)
    }
    return config
  }

  static getAllConfigs(): ItemConfig[] {
    return Array.from(this.itemConfigs.values())
  }

  static getRandomItemType(): ItemType {
    const configs = Array.from(this.itemConfigs.values())
    const totalWeight = configs.reduce((sum, config) => sum + config.spawnWeight, 0)
    
    let random = Math.random() * totalWeight
    for (const config of configs) {
      random -= config.spawnWeight
      if (random <= 0) {
        return config.type
      }
    }
    
    return ItemType.COIN // é»˜è®¤è¿”å›é‡‘å¸
  }

  static createRandomItem(x: number, y: number): Item {
    const type = this.getRandomItemType()
    return new Item(x, y, type)
  }
}

// é“å…·æ•ˆæœç®¡ç†å™¨
export class EffectManager {
  private activeEffects: Map<ItemType, { effect: ItemEffect, startTime: number }> = new Map()
  private timeScale: number = 1.0

  applyEffect(effect: ItemEffect, type: ItemType): void {
    if (effect.type === EffectType.INSTANT) {
      // ç¬æ—¶æ•ˆæœç›´æ¥å¤„ç†
      return
    }

    if (effect.type === EffectType.DURATION) {
      if (!effect.stackable && this.activeEffects.has(type)) {
        // å¦‚æœä¸å¯å åŠ ä¸”å·²å­˜åœ¨ï¼Œé‡ç½®æ—¶é—´
        const existing = this.activeEffects.get(type)!
        existing.startTime = Date.now()
      } else {
        // æ·»åŠ æ–°æ•ˆæœ
        this.activeEffects.set(type, {
          effect: effect,
          startTime: Date.now()
        })
      }
    }
  }

  update(deltaTime: number): void {
    const currentTime = Date.now()
    const expiredEffects: ItemType[] = []

    for (const [type, activeEffect] of this.activeEffects) {
      const elapsed = currentTime - activeEffect.startTime
      if (activeEffect.effect.duration && elapsed >= activeEffect.effect.duration) {
        expiredEffects.push(type)
      }
    }

    // ç§»é™¤è¿‡æœŸæ•ˆæœ
    for (const type of expiredEffects) {
      this.activeEffects.delete(type)
    }

    // æ›´æ–°æ—¶é—´ç¼©æ”¾
    this.updateTimeScale()
  }

  private updateTimeScale(): void {
    const slowTimeEffect = this.activeEffects.get(ItemType.SLOW_TIME)
    if (slowTimeEffect) {
      this.timeScale = slowTimeEffect.effect.value
    } else {
      this.timeScale = 1.0
    }
  }

  hasEffect(type: ItemType): boolean {
    return this.activeEffects.has(type)
  }

  getEffectValue(type: ItemType): number {
    const effect = this.activeEffects.get(type)
    return effect ? effect.effect.value : 1
  }

  getTimeScale(): number {
    return this.timeScale
  }

  getRemainingTime(type: ItemType): number {
    const effect = this.activeEffects.get(type)
    if (!effect || !effect.effect.duration) return 0
    
    const elapsed = Date.now() - effect.startTime
    return Math.max(0, effect.effect.duration - elapsed)
  }

  clearAllEffects(): void {
    this.activeEffects.clear()
    this.timeScale = 1.0
  }

  getActiveEffects(): ItemType[] {
    return Array.from(this.activeEffects.keys())
  }
}

// å¯¼å‡ºå•ä¾‹
export const itemManager = new ItemManager()
export const effectManager = new EffectManager()

// åˆå§‹åŒ–é“å…·ç³»ç»Ÿ
ItemManager.initialize()